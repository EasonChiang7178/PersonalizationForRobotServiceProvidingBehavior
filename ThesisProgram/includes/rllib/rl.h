/*   This file is part of rl-lib
 *
 *   Copyright (C) 2010,  Supelec
 *
 *   Author : Herve Frezza-Buet and Matthieu Geist
 *
 *   Contributor :
 *
 *   This library is free software; you can redistribute it and/or
 *   modify it under the terms of the GNU General Public
 *   License (GPL) as published by the Free Software Foundation; either
 *   version 3 of the License, or any later version.
 *   
 *   This library is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 *   General Public License for more details.
 *   
 *   You should have received a copy of the GNU General Public
 *   License along with this library; if not, write to the Free Software
 *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *
 *   Contact : Herve.Frezza-Buet@supelec.fr Matthieu.Geist@supelec.fr
 *
 */
#ifndef rl_H
#define rl_H

#include <gsl/gsl_vector.h>
#include <cmath>
#include <rlAgent.h>
#include <rlRandom.h>
#include <rlException.h>
#include <rlGreedy.h>
#include <rlTypes.h>
#include <rlTransition.h>
#include <rlLSTD.h>
#include <rlKTD.h>
#include <rlOffPAPI.h>
#include <rlQLearning.h>
#include <rlSARSA.h>
#include <rlMLP.h>
#include <rlLinear.h>

#include <rl-boyan-chain.h>
#include <rl-mountain-car.h>
#include <rl-inverted-pendulum.h>
#include <rl-cliff-walking.h>

#include <rl-adaptive-interruption.h>

/**
 * @example example-000-000-overview.cc
 */

/**
 * @example example-000-001-simulator.cc
 */

/**
 * @example example-000-002-learning.cc
 */

/**
 * @example example-000-003-agents.cc
 */

/**
 * @example example-001-001-cliff-walking-sarsa.cc
 */

/**
 * @example example-001-002-cliff-walking-qlearning.cc
 */


/**
 * @example example-002-001-boyan-lstd.cc
 */

/**
 * @example example-002-002-pendulum-lspi.cc
 */

/**
 * @example example-003-001-pendulum-ktdq.cc
 */

/**
 * @example example-003-002-pendulum-mlp-ktdq.cc
 */

/**
 * @example example-003-003-mountain-car-ktdsarsa.cc
 */

/**
 * @example rl-boyan-chain.h
 */

/**
 * @example rl-cliff-walking.h
 */

/**
 * @example rl-mountain-car.h
 */

/**
 * @example rl-inverted-pendulum.h
 */

/**
 * @example example-defs-transition.h
 */

/**
 * @example example-defs-tabular-cliff.h
 */

/**
 * @example example-defs-cliff-experiments.h
 */

/**
 * @example example-defs-pendulum-architecture.h
 */

/**
 * @example example-defs-test-iteration.h
 */

/**
 * @example example-defs-ktdq-experiments.h
 */

/**
 * @example example-defs-mountain-car-architecture.h
 */








/**
 * @mainpage
 *
 * @section Overview
 * 
 * The rl library is not a framework where you can plug your own
 * algorithms by complying to predefined interfaces. It is rather a set
 * of tools that helps you designing your work or experiment from
 * scratch. The main function is yours, and you are responsible for
 * scheduling everything from it, for creating every object that you
 * need.
 *
 * In such a design, the library offers ready-to-use algorithms and
 * types written as templates. Using the template is equivalent as
 * asking some programmer to write for you a code that is dedicated to
 * your application.
 *
 * This documentation contains both a reference and a user manual. The
 * reference manual is given by the Doxygen structure of class
 * names, as usually. The user manual is a better way to get familiar
 * with the library. The user manual, here, consists of the set of
 * examples. You can start by reading them, <b>in the suggested
 * order</b> (examples all have a number).
 *
 * The use of templates may be considered as adding programming
 * complexity. The point is that this kind of genericity, based on a
 * re-writing mechanism at compiling time that writes code for you,
 * makes the design close to the mathematics. The cost is that you
 * spend time to make sure that you fit the requirements when you use
 * some rl object. If you don't, you will get some very complicated
 * syntax error message. This is clearly the drawback of the use of
 * templates. Nevertheless, once it compiles, the code you get is
 * quite safe. Our philosophy is that fixing syntax error is a finite
 * process, as opposed to bug fixing.
 *
 * @section tailor Tailoring your code with typedefs
 *
 * As you will see when browsing examples, it often contains a list of
 * typedefs. This is a smart way to cope with quite complicated types
 * generated by templates. For example:
 * 
 * @code
typedef rl::problem::mountain_car::DefaultParam        mcParam;
typedef rl::problem::mountain_car::Simulator<mcParam>  Simulator;
typedef Simulator::action_type                         A;
 * @endcode
 * So when you write afterward:
 * @code
 A optimal_action;
 * @endcode
 * It is as if you had written:
 * @code
 rl::problem::mountain_car::Simulator<rl::problem::mountain_car::DefaultParam>::action_type optimal_action;
 * @endcode
 * This raises a problem when syntax error occur, since error message displays the complicated version of your types.
 *
 * @section concept The use of concepts
 *
 * There is not a clean support of concepts in the version of c++ that
 * we use. In order to help the designers, we have made explicit concepts
 * in classes, that are just aimed at being documented here, and that
 * are never used in the code. They are gathered in the rl::concept
 * namespace. The convention is the following. If you need a rl
 * template whose documentation is like this:
 *
 * @code
namespace rl {
  template<typename STUFF, typename SA_FOO, typename SA_BAR>
  class DummyAlgorithm {
  public:
    double computeResult(void);
  };
}
 * @endcode
 *
 * You have to search in the documentation for concepts
 * rl::concept::Stuff, rl::concept::sa::Foo, rl::concept::sa::Bar, as
 * suggests the names of the formal template parameters of
 * DummyAlgorithm. Let us suppose that you find this.
 *
 * @code
namespace rl {
  namespace concept {
  
    template<typename ANY>
    class Stuff {
    public:
      typedef ANY any_type;
      void interpret(any_type& a);
    };

    namespace sa {
      template<typename VALUE>
      class FooBase {
      public:
        typedef VALUE value_type;
        value_type get(void);
      };

      template<typename VALUE>
      class Foo : public FooBase {
      public:
        void set(const value_type& v);
      };

      class Bar {
      public:
         static int size(void);
      };
    }
  }
}
 * @endcode
 *
 * It does not mean at all that you have to inherit from the previous
 * classes in order to provide type parameters to the DummyAlgorithm
 * class. Rather, it means that you have to design a class <b>accordingly</b>
 * to the concept classes. Let us make a class that fits all the three
 * rl::concept::Stuff, rl::concept::sa::Foo and rl::concept::sa::Bar
 * concepts. You just have to copy-paste from the concept
 * documentation.
 *
 * @code
class ThreeInOne {
public:

  // This fits rl::concept::Stuff<std::string>

  typedef std::string any_type;

  void interpret(any_type& a) { 
    // your code here 
  }

  // This fits rl::concept::sa::Foo<int>... and 
  // rl::concept::sa::FooBase<int> since Foo inherits 
  // from FooBase

  typedef int value_type;

  value_type get(void) {
    // your code here 
  }

  void set(const value_type& v) {
    // your code here 
  }

  // This fits rl::concept::sa::Bar

  static int size(void) {
    // your code here 
  }
};
 * @endcode
 *
 * Once this ThreeInOne class is defined, it can be used as a type
 * parameter for the three slots in the DummyAlgorithm template, since
 * it fits the three requirements.
 *
 * @code
typedef rl::DummyAlgorithm<ThreeInOne,ThreeInOne,ThreeInOne> MyAlgo;
...
MyAlgo algo;
double res = algo.computeResult;
 * @endcode
 *
 * Fitting to the concepts ensures that your code will compile. It
 * also induce a very strong type checking, that may be annoying at
 * compiling time if you do not perfectly fit the concepts, but that
 * brings a lot of safety at run time.
 *
 * @section start Getting started 
 *
 * You are now ready to read the examples following the order induced
 * by the file names, and of course you can design you own
 * experiments, inspiring from the code in the examples. In order to
 * compile your code, pkg-config support is available (unix).
 *
 * @code
g++ -o example.bin file.cc `pkg-config --cflags --libs rl`
./example.bin
 * @endcode
 * or more generally
 * @code
g++ -c file1.cc `pkg-config --cflags rl`
g++ -c file2.cc `pkg-config --cflags rl`
...
g++ -c fileN.cc `pkg-config --cflags rl`

g++ -o example.bin *.o `pkg-config --libs rl`
./example.bin
 * @endcode
 */



#endif
